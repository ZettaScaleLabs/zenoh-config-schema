{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Zenoh Configuration Schema",
  "description": "Configuration schema for Zenoh generated by Claude Opus 4.5 from tag 1.7.2 on 19-01-2025.",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "The identifier (as unsigned 128bit integer in hexadecimal lowercase - leading zeros are not accepted) that zenoh runtime will use. If not set, a random unsigned 128bit integer will be used. WARNING: this id must be unique in your zenoh network.",
      "pattern": "^[1-9a-f][0-9a-f]*$"
    },
    "mode": {
      "type": "string",
      "description": "The node's mode (router, peer or client)",
      "enum": [
        "router",
        "peer",
        "client"
      ]
    },
    "metadata": {
      "type": "object",
      "description": "The node's metadata (name, location, DNS name, etc.) Arbitrary JSON data not interpreted by zenoh and available in admin space @/<zid>/router, @/<zid>/peer or @/<zid>/client",
      "additionalProperties": true
    },
    "connect": {
      "type": "object",
      "description": "Which endpoints to connect to. E.g. tcp/localhost:7447. By configuring the endpoints, it is possible to tell zenoh which router/peer to connect to at startup. For TCP/UDP on Linux, it is possible additionally specify the interface to be connected to: E.g. tcp/192.168.0.1:7447#iface=eth0, for connect only if the IP address is reachable via the interface eth0. It is also possible to specify a priority range and/or a reliability setting to be used on the link. For example `tcp/localhost?prio=6-7;rel=0` assigns priorities \"data_low\" and \"background\" to the established link. For TCP and TLS links, it is possible to specify the TCP buffer sizes: E.g. tcp/192.168.0.1:7447#so_sndbuf=65000;so_rcvbuf=65000. For TCP, UDP, Quic and TLS links, it is possible to specify a `bind` address for the local socket: E.g. tcp/192.168.0.1:7447#bind=192.168.0.1:0. Note!: Currently it is unsupported to specify both `bind` and `iface`. For TCP/UDP links, it's possible to specify the DSCP field of the IP header: E.g. tcp/192.168.0.1:7447#dscp=0x08",
      "properties": {
        "timeout_ms": {
          "description": "Timeout waiting for all endpoints connected (0: no retry, -1: infinite timeout). Accepts a single value (e.g. timeout_ms: 0) or different values for router, peer and client (e.g. timeout_ms: { router: -1, peer: -1, client: 0 }).",
          "oneOf": [
            {
              "type": "integer"
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "integer"
                },
                "peer": {
                  "type": "integer"
                },
                "client": {
                  "type": "integer"
                }
              }
            }
          ]
        },
        "endpoints": {
          "description": "The list of endpoints to connect to. Accepts a single list (e.g. endpoints: [\"tcp/10.10.10.10:7447\", \"tcp/11.11.11.11:7447\"]) or different lists for router, peer and client (e.g. endpoints: { router: [\"tcp/10.10.10.10:7447\"], peer: [\"tcp/11.11.11.11:7447\"] }). See https://docs.rs/zenoh/latest/zenoh/config/struct.EndPoint.html",
          "oneOf": [
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "peer": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "client": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        },
        "exit_on_failure": {
          "description": "Exit from application if timeout exceeded. Global connect configuration. Accepts a single value or different values for router, peer and client. The configuration can also be specified for the separate endpoint, it will override the global one. E.g. tcp/192.168.0.1:7447#retry_period_init_ms=20000;retry_period_max_ms=10000",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "boolean"
                },
                "peer": {
                  "type": "boolean"
                },
                "client": {
                  "type": "boolean"
                }
              }
            }
          ]
        },
        "retry": {
          "type": "object",
          "description": "Connect establishing retry configuration",
          "properties": {
            "period_init_ms": {
              "type": "integer",
              "description": "Initial wait timeout until next connect try"
            },
            "period_max_ms": {
              "type": "integer",
              "description": "Maximum wait timeout until next connect try"
            },
            "period_increase_factor": {
              "type": "number",
              "description": "Increase factor for the next timeout until next connect try"
            }
          }
        }
      }
    },
    "listen": {
      "type": "object",
      "description": "Which endpoints to listen on. E.g. tcp/0.0.0.0:7447. By configuring the endpoints, it is possible to tell zenoh which are the endpoints that other routers, peers, or client can use to establish a zenoh session. For TCP/UDP on Linux, it is possible additionally specify the interface to be listened to: E.g. tcp/0.0.0.0:7447#iface=eth0, for listen connection only on eth0. It is also possible to specify a priority range and/or a reliability setting to be used on the link. For example `tcp/localhost?prio=6-7;rel=0` assigns priorities \"data_low\" and \"background\" to the established link. For TCP and TLS links, it is possible to specify the TCP buffer sizes: E.g. tcp/192.168.0.1:7447#so_sndbuf=65000;so_rcvbuf=65000. For TCP/UDP links, it's possible to specify the DSCP field of the IP header: E.g. tcp/192.168.0.1:7447#dscp=0x08",
      "properties": {
        "timeout_ms": {
          "description": "Timeout waiting for all listen endpoints (0: no retry, -1: infinite timeout). Accepts a single value (e.g. timeout_ms: 0) or different values for router, peer and client (e.g. timeout_ms: { router: -1, peer: -1, client: 0 }).",
          "oneOf": [
            {
              "type": "integer"
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "integer"
                },
                "peer": {
                  "type": "integer"
                },
                "client": {
                  "type": "integer"
                }
              }
            }
          ]
        },
        "endpoints": {
          "description": "The list of endpoints to listen on. Accepts a single list (e.g. endpoints: [\"tcp/[::]:7447\", \"udp/[::]:7447\"]) or different lists for router, peer and client (e.g. endpoints: { router: [\"tcp/[::]:7447\"], peer: [\"tcp/[::]:0\"] }). See https://docs.rs/zenoh/latest/zenoh/config/struct.EndPoint.html",
          "oneOf": [
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "peer": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "client": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        },
        "exit_on_failure": {
          "description": "Exit from application if timeout exceeded. Global listen configuration. Accepts a single value or different values for router, peer and client. The configuration can also be specified for the separate endpoint, it will override the global one. E.g. tcp/192.168.0.1:7447#exit_on_failure=false;retry_period_max_ms=1000",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "boolean"
                },
                "peer": {
                  "type": "boolean"
                },
                "client": {
                  "type": "boolean"
                }
              }
            }
          ]
        },
        "retry": {
          "type": "object",
          "description": "Listen retry configuration",
          "properties": {
            "period_init_ms": {
              "type": "integer",
              "description": "Initial wait timeout until next try"
            },
            "period_max_ms": {
              "type": "integer",
              "description": "Maximum wait timeout until next try"
            },
            "period_increase_factor": {
              "type": "number",
              "description": "Increase factor for the next timeout until next try"
            }
          }
        }
      }
    },
    "open": {
      "type": "object",
      "description": "Configure the session open behavior.",
      "properties": {
        "return_conditions": {
          "type": "object",
          "description": "Configure the conditions to be met before session open returns.",
          "properties": {
            "connect_scouted": {
              "type": "boolean",
              "description": "Session open waits to connect to scouted peers and routers before returning. When set to false, first publications and queries after session open from peers may be lost."
            },
            "declares": {
              "type": "boolean",
              "description": "Session open waits to receive initial declares from connected peers before returning. Setting to false may cause extra traffic at startup from peers."
            }
          }
        }
      }
    },
    "scouting": {
      "type": "object",
      "description": "Configure the scouting mechanisms and their behaviours",
      "properties": {
        "timeout": {
          "type": "integer",
          "description": "In client mode, the period in milliseconds dedicated to scouting for a router before failing."
        },
        "delay": {
          "type": "integer",
          "description": "In peer mode, the maximum period in milliseconds dedicated to scouting remote peers before attempting other operations."
        },
        "multicast": {
          "type": "object",
          "description": "The multicast scouting configuration.",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether multicast scouting is enabled or not"
            },
            "address": {
              "type": "string",
              "description": "The socket which should be used for multicast scouting"
            },
            "interface": {
              "type": "string",
              "description": "The network interface which should be used for multicast scouting. If not set or set to \"auto\" the interface is picked automatically."
            },
            "ttl": {
              "type": "integer",
              "description": "The time-to-live on multicast scouting packets"
            },
            "autoconnect": {
              "description": "Which type of Zenoh instances to automatically establish sessions with upon discovery on UDP multicast. Accepts a single value (e.g. autoconnect: [\"router\", \"peer\"]) which applies whatever the configured \"mode\" is, or different values for router, peer or client mode (e.g. autoconnect: { router: [], peer: [\"router\", \"peer\"] }). Each value is a list of: \"peer\", \"router\" and/or \"client\".",
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "router",
                      "peer",
                      "client"
                    ]
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "router": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer",
                          "client"
                        ]
                      }
                    },
                    "peer": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer",
                          "client"
                        ]
                      }
                    },
                    "client": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer",
                          "client"
                        ]
                      }
                    }
                  }
                }
              ]
            },
            "autoconnect_strategy": {
              "description": "Strategy for autoconnection, mainly to avoid nodes connecting to each other redundantly. Possible options are: \"always\" (always attempt to autoconnect, may result in redundant connections), \"greater-zid\" (attempt to connect to another node only if its own zid is greater than the other's; if both nodes use this strategy, only one will attempt the connection; this strategy may not be suited if one of the nodes is not reachable by the other one, for example because of a private IP). Accepts a single value which applies whatever node would be auto-connected to, or different values for router and/or peer depending on the type of node detected (e.g. autoconnect_strategy: { to_router: \"always\", to_peer: \"greater-zid\" }), or different values for router or peer mode (e.g. autoconnect_strategy: { peer: { to_router: \"always\", to_peer: \"greater-zid\" } }).",
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "always",
                    "greater-zid"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "to_router": {
                      "type": "string",
                      "enum": [
                        "always",
                        "greater-zid"
                      ]
                    },
                    "to_peer": {
                      "type": "string",
                      "enum": [
                        "always",
                        "greater-zid"
                      ]
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "router": {
                      "oneOf": [
                        {
                          "type": "string",
                          "enum": [
                            "always",
                            "greater-zid"
                          ]
                        },
                        {
                          "type": "object",
                          "properties": {
                            "to_router": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            },
                            "to_peer": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            }
                          }
                        }
                      ]
                    },
                    "peer": {
                      "oneOf": [
                        {
                          "type": "string",
                          "enum": [
                            "always",
                            "greater-zid"
                          ]
                        },
                        {
                          "type": "object",
                          "properties": {
                            "to_router": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            },
                            "to_peer": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            }
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            },
            "listen": {
              "type": "boolean",
              "description": "Whether or not to listen for scout messages on UDP multicast and reply to them."
            }
          }
        },
        "gossip": {
          "type": "object",
          "description": "The gossip scouting configuration. Note that instances in \"client\" mode do not participate in gossip.",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether gossip scouting is enabled or not"
            },
            "multihop": {
              "type": "boolean",
              "description": "When true, gossip scouting information are propagated multiple hops to all nodes in the local network. When false, gossip scouting information are only propagated to the next hop. Activating multihop gossip implies more scouting traffic and a lower scalability. It mostly makes sense when using \"linkstate\" routing mode where all nodes in the subsystem don't have direct connectivity with each other."
            },
            "target": {
              "description": "Which type of Zenoh instances to send gossip messages to. Accepts a single value (e.g. target: [\"router\", \"peer\"]) which applies whatever the configured \"mode\" is, or different values for router or peer mode (e.g. target: { router: [\"router\", \"peer\"], peer: [\"router\"] }). Each value is a list of \"peer\" and/or \"router\".",
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "router",
                      "peer"
                    ]
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "router": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer"
                        ]
                      }
                    },
                    "peer": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer"
                        ]
                      }
                    }
                  }
                }
              ]
            },
            "autoconnect": {
              "description": "Which type of Zenoh instances to automatically establish sessions with upon discovery on gossip. Accepts a single value (e.g. autoconnect: [\"router\", \"peer\"]) which applies whatever the configured \"mode\" is, or different values for router or peer mode (e.g. autoconnect: { router: [], peer: [\"router\", \"peer\"] }). Each value is a list of: \"peer\" and/or \"router\".",
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "router",
                      "peer"
                    ]
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "router": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer"
                        ]
                      }
                    },
                    "peer": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "router",
                          "peer"
                        ]
                      }
                    }
                  }
                }
              ]
            },
            "autoconnect_strategy": {
              "description": "Strategy for autoconnection, mainly to avoid nodes connecting to each other redundantly. Possible options are: \"always\" (always attempt to autoconnect, may result in redundant connections), \"greater-zid\" (attempt to connect to another node only if its own zid is greater than the other's; if both nodes use this strategy, only one will attempt the connection; this strategy may not be suited if one of the nodes is not reachable by the other one, for example because of a private IP). Accepts a single value which applies whatever node would be auto-connected to, or different values for router and/or peer depending on the type of node detected, or different values for router or peer mode.",
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "always",
                    "greater-zid"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "to_router": {
                      "type": "string",
                      "enum": [
                        "always",
                        "greater-zid"
                      ]
                    },
                    "to_peer": {
                      "type": "string",
                      "enum": [
                        "always",
                        "greater-zid"
                      ]
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "router": {
                      "oneOf": [
                        {
                          "type": "string",
                          "enum": [
                            "always",
                            "greater-zid"
                          ]
                        },
                        {
                          "type": "object",
                          "properties": {
                            "to_router": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            },
                            "to_peer": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            }
                          }
                        }
                      ]
                    },
                    "peer": {
                      "oneOf": [
                        {
                          "type": "string",
                          "enum": [
                            "always",
                            "greater-zid"
                          ]
                        },
                        {
                          "type": "object",
                          "properties": {
                            "to_router": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            },
                            "to_peer": {
                              "type": "string",
                              "enum": [
                                "always",
                                "greater-zid"
                              ]
                            }
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            }
          }
        }
      }
    },
    "timestamping": {
      "type": "object",
      "description": "Configuration of data messages timestamps management.",
      "properties": {
        "enabled": {
          "description": "Whether data messages should be timestamped if not already. Accepts a single boolean value or different values for router, peer and client.",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "object",
              "properties": {
                "router": {
                  "type": "boolean"
                },
                "peer": {
                  "type": "boolean"
                },
                "client": {
                  "type": "boolean"
                }
              }
            }
          ]
        },
        "drop_future_timestamp": {
          "type": "boolean",
          "description": "Whether data messages with timestamps in the future should be dropped or not. If set to false (default), messages with timestamps in the future are retimestamped. Timestamps are ignored if timestamping is disabled."
        }
      }
    },
    "queries_default_timeout": {
      "type": "integer",
      "description": "The default timeout to apply to queries in milliseconds."
    },
    "routing": {
      "type": "object",
      "description": "The routing strategy to use and its configuration.",
      "properties": {
        "router": {
          "type": "object",
          "description": "The routing strategy to use in routers and its configuration.",
          "properties": {
            "peers_failover_brokering": {
              "type": "boolean",
              "description": "When set to true a router will forward data between two peers directly connected to it if it detects that those peers are not connected to each other. The failover brokering only works if gossip discovery is enabled and peers are configured with gossip target \"router\"."
            },
            "linkstate": {
              "type": "object",
              "description": "Linkstate mode configuration.",
              "properties": {
                "transport_weights": {
                  "type": "array",
                  "description": "Weights of the outgoing transports in linkstate mode. If none of the two endpoint nodes of a transport specifies its weight, a weight of 100 is applied. If only one of the two endpoint nodes of a transport specifies its weight, the specified weight is applied. If both endpoint nodes of a transport specify its weight, the greater weight is applied.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "dst_zid": {
                        "type": "string"
                      },
                      "weight": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "peer": {
          "type": "object",
          "description": "The routing strategy to use in peers and its configuration.",
          "properties": {
            "mode": {
              "type": "string",
              "description": "The routing strategy to use in peers (\"peer_to_peer\" or \"linkstate\"). This option needs to be set to the same value in all peers and routers of the subsystem.",
              "enum": [
                "peer_to_peer",
                "linkstate"
              ]
            },
            "linkstate": {
              "type": "object",
              "description": "Linkstate mode configuration (only taken into account if mode == \"linkstate\").",
              "properties": {
                "transport_weights": {
                  "type": "array",
                  "description": "Weights of the outgoing transports in linkstate mode. If none of the two endpoint nodes of a transport specifies its weight, a weight of 100 is applied. If only one of the two endpoint nodes of a transport specifies its weight, the specified weight is applied. If both endpoint nodes of a transport specify its weight, the greater weight is applied.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "dst_zid": {
                        "type": "string"
                      },
                      "weight": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "interests": {
          "type": "object",
          "description": "The interests-based routing configuration. This configuration applies regardless of the mode (router, peer or client).",
          "properties": {
            "timeout": {
              "type": "integer",
              "description": "The timeout to wait for incoming interests declarations in milliseconds. The expiration of this timeout implies that the discovery protocol might be incomplete, leading to potential loss of messages, queries or liveliness tokens."
            }
          }
        }
      }
    },
    "qos": {
      "type": "object",
      "description": "Overwrite QoS options for Zenoh messages by key expression (ignores Zenoh API QoS config for overwritten values)",
      "properties": {
        "publication": {
          "type": "array",
          "description": "Overwrite QoS options for PUT and DELETE messages",
          "items": {
            "type": "object",
            "properties": {
              "key_exprs": {
                "type": "array",
                "description": "PUT and DELETE messages on key expressions that are included by these key expressions will have their QoS options overwritten by the given config.",
                "items": {
                  "type": "string"
                }
              },
              "config": {
                "type": "object",
                "description": "Configurations that will be applied on the publisher. Options that are supplied here will overwrite the configuration given in Zenoh API",
                "properties": {
                  "congestion_control": {
                    "type": "string",
                    "enum": [
                      "drop",
                      "block"
                    ]
                  },
                  "priority": {
                    "type": "string",
                    "enum": [
                      "real_time",
                      "interactive_high",
                      "interactive_low",
                      "data_high",
                      "data",
                      "data_low",
                      "background"
                    ]
                  },
                  "express": {
                    "type": "boolean"
                  },
                  "reliability": {
                    "type": "string",
                    "enum": [
                      "reliable",
                      "best_effort"
                    ]
                  },
                  "allowed_destination": {
                    "type": "string",
                    "enum": [
                      "local",
                      "remote",
                      "any"
                    ]
                  }
                }
              }
            }
          }
        },
        "network": {
          "type": "array",
          "description": "Overwrite QoS options for messages sent and received from/to the network. This allows more fine grained rules (per network card, etc...) but is less performant than the publication option above.",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Optional Id, has to be unique."
              },
              "zids": {
                "type": "array",
                "description": "Optional list of ZIDs on which qos will be overwritten when communicating with.",
                "items": {
                  "type": "string"
                }
              },
              "interfaces": {
                "type": "array",
                "description": "Optional list of interfaces, if not specified, will be applied to all interfaces.",
                "items": {
                  "type": "string"
                }
              },
              "link_protocols": {
                "type": "array",
                "description": "Optional list of link protocols. Transports with at least one of these links will have their qos overwritten. If absent, the overwrite will be applied to all transports. An empty list is invalid.",
                "items": {
                  "type": "string",
                  "enum": [
                    "tcp",
                    "udp",
                    "tls",
                    "quic",
                    "ws",
                    "serial",
                    "unixsock-stream",
                    "unixpipe",
                    "vsock"
                  ]
                }
              },
              "messages": {
                "type": "array",
                "description": "List of message types to apply to.",
                "items": {
                  "type": "string",
                  "enum": [
                    "put",
                    "delete",
                    "query",
                    "reply"
                  ]
                }
              },
              "flows": {
                "type": "array",
                "description": "Optional list of data flows messages will be processed on (\"egress\" and/or \"ingress\"). If absent, the rules will be applied to both flows.",
                "items": {
                  "type": "string",
                  "enum": [
                    "egress",
                    "ingress"
                  ]
                }
              },
              "qos": {
                "type": "object",
                "description": "QoS filter to apply to the messages matching this item.",
                "properties": {
                  "congestion_control": {
                    "type": "string",
                    "enum": [
                      "drop",
                      "block"
                    ]
                  },
                  "priority": {
                    "type": "string",
                    "enum": [
                      "real_time",
                      "interactive_high",
                      "interactive_low",
                      "data_high",
                      "data",
                      "data_low",
                      "background"
                    ]
                  },
                  "express": {
                    "type": "boolean"
                  },
                  "reliability": {
                    "type": "string",
                    "enum": [
                      "reliable",
                      "best_effort"
                    ]
                  }
                }
              },
              "payload_size": {
                "type": "string",
                "description": "Payload size range for the messages matching this item."
              },
              "key_exprs": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "overwrite": {
                "type": "object",
                "properties": {
                  "priority": {
                    "type": "string",
                    "description": "Optional new priority value, if not specified priority of the messages will stay unchanged.",
                    "enum": [
                      "real_time",
                      "interactive_high",
                      "interactive_low",
                      "data_high",
                      "data",
                      "data_low",
                      "background"
                    ]
                  },
                  "congestion_control": {
                    "type": "string",
                    "description": "Optional new congestion control value, if not specified congestion control of the messages will stay unchanged.",
                    "enum": [
                      "drop",
                      "block"
                    ]
                  },
                  "express": {
                    "type": "boolean",
                    "description": "Optional new express value, if not specified express flag of the messages will stay unchanged."
                  }
                }
              }
            }
          }
        }
      }
    },
    "aggregation": {
      "type": "object",
      "description": "The declarations aggregation strategy.",
      "properties": {
        "subscribers": {
          "type": "array",
          "description": "A list of key-expressions for which all included subscribers will be aggregated into.",
          "items": {
            "type": "string"
          }
        },
        "publishers": {
          "type": "array",
          "description": "A list of key-expressions for which all included publishers will be aggregated into.",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "namespace": {
      "type": "string",
      "description": "Namespace prefix. If specified, all outgoing key expressions will be automatically prefixed with specified string, and all incoming key expressions will be stripped of specified prefix. The namespace prefix should satisfy all key expression constraints and additionally it can not contain wild characters ('*'). Namespace is applied to the session. E.g. if session has a namespace of \"1\" then session.put(\"my/keyexpr\", my_message), will put a message into 1/my/keyexpr. Same applies to all other operations within this session."
    },
    "downsampling": {
      "type": "array",
      "description": "The downsampling declaration.",
      "items": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Optional Id, has to be unique"
          },
          "interfaces": {
            "type": "array",
            "description": "Optional list of network interfaces messages will be processed on, the rest will be passed as is. If absent, the rules will be applied to all interfaces. An empty list is invalid.",
            "items": {
              "type": "string"
            }
          },
          "link_protocols": {
            "type": "array",
            "description": "Optional list of link protocols. Transports with at least one of these links will have their messages filtered. If absent, the rules will be applied to all transports. An empty list is invalid.",
            "items": {
              "type": "string",
              "enum": [
                "tcp",
                "udp",
                "tls",
                "quic",
                "ws",
                "serial",
                "unixsock-stream",
                "unixpipe",
                "vsock"
              ]
            }
          },
          "flows": {
            "type": "array",
            "description": "Optional list of data flows messages will be processed on (\"egress\" and/or \"ingress\"). If absent, the rules will be applied to both flows.",
            "items": {
              "type": "string",
              "enum": [
                "ingress",
                "egress"
              ]
            }
          },
          "messages": {
            "type": "array",
            "description": "List of message type on which downsampling will be applied. Must not be empty. Options: \"delete\" (Delete), \"put\" (Put), \"query\" (Get), \"reply\" (Queryable Reply to a Query).",
            "items": {
              "type": "string",
              "enum": [
                "delete",
                "put",
                "query",
                "reply"
              ]
            }
          },
          "rules": {
            "type": "array",
            "description": "A list of downsampling rules: key_expression and the maximum frequency in Hertz",
            "items": {
              "type": "object",
              "properties": {
                "key_expr": {
                  "type": "string"
                },
                "freq": {
                  "type": "number"
                }
              },
              "required": [
                "key_expr",
                "freq"
              ]
            }
          }
        }
      }
    },
    "access_control": {
      "type": "object",
      "description": "Configure access control (ACL) rules",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "[true/false] acl will be activated only if this is set to true"
        },
        "default_permission": {
          "type": "string",
          "description": "[deny/allow] default permission is deny (even if this is left empty or not specified)",
          "enum": [
            "deny",
            "allow"
          ]
        },
        "rules": {
          "type": "array",
          "description": "Rule set for permissions allowing or denying access to key-expressions",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Id has to be unique within the rule set"
              },
              "messages": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "put",
                    "delete",
                    "declare_subscriber",
                    "query",
                    "reply",
                    "declare_queryable",
                    "liveliness_token",
                    "liveliness_query",
                    "declare_liveliness_subscriber"
                  ]
                }
              },
              "flows": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "egress",
                    "ingress"
                  ]
                }
              },
              "permission": {
                "type": "string",
                "enum": [
                  "allow",
                  "deny"
                ]
              },
              "key_exprs": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "id",
              "messages",
              "permission",
              "key_exprs"
            ]
          }
        },
        "subjects": {
          "type": "array",
          "description": "List of combinations of subjects. If a subject property (i.e. username, certificate common name or interface) is empty it is interpreted as a wildcard. Moreover, a subject property cannot be an empty list.",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Id has to be unique within the subjects list"
              },
              "interfaces": {
                "type": "array",
                "description": "Subjects can be interfaces",
                "items": {
                  "type": "string"
                }
              },
              "cert_common_names": {
                "type": "array",
                "description": "Subjects can be cert_common_names when using TLS or Quic",
                "items": {
                  "type": "string"
                }
              },
              "usernames": {
                "type": "array",
                "description": "Subjects can be usernames when using user/password authentication",
                "items": {
                  "type": "string"
                }
              },
              "link_protocols": {
                "type": "array",
                "description": "Link protocols can also be used to identify transports to filter messages on. If absent, the rules will be applied to all transports. An empty list is invalid.",
                "items": {
                  "type": "string",
                  "enum": [
                    "tcp",
                    "udp",
                    "tls",
                    "quic",
                    "ws",
                    "serial",
                    "unixsock-stream",
                    "unixpipe",
                    "vsock"
                  ]
                }
              },
              "zids": {
                "type": "array",
                "description": "ZIDs can also be used to identify transports to filter messages on. NOTE: ZID is not backed by an authentication mechanism, it can only be trusted for ACL if it is dynamically added/removed by eventual dedicated Zenoh mechanisms when transports are opened/closed. If managed manually in ACL config, can be useful for prototyping but should not be used in production!",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "id"
            ]
          }
        },
        "policies": {
          "type": "array",
          "description": "The policies list associates rules to subjects. Each policy associates one or multiple rules to one or multiple subject combinations.",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Id is optional. If provided, it has to be unique within the policies list"
              },
              "rules": {
                "type": "array",
                "description": "Rules are identified with their unique IDs declared above",
                "items": {
                  "type": "string"
                }
              },
              "subjects": {
                "type": "array",
                "description": "Subjects are identified with their unique IDs declared above",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "rules",
              "subjects"
            ]
          }
        }
      }
    },
    "low_pass_filter": {
      "type": "array",
      "description": "Low pass filter configuration.",
      "items": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Optional Id, has to be unique"
          },
          "interfaces": {
            "type": "array",
            "description": "Optional list of network interfaces messages will be processed on, the rest will not be filtered. If absent, the filter will be applied to all interfaces.",
            "items": {
              "type": "string"
            }
          },
          "link_protocols": {
            "type": "array",
            "description": "Optional list of link protocols. Transports with at least one of these links will have their messages filtered. If absent, the rule will be applied to all transports. An empty list is invalid.",
            "items": {
              "type": "string",
              "enum": [
                "tcp",
                "udp",
                "tls",
                "quic",
                "ws",
                "serial",
                "unixsock-stream",
                "unixpipe",
                "vsock"
              ]
            }
          },
          "flows": {
            "type": "array",
            "description": "Optional list of data flows messages will be processed on (\"egress\" and/or \"ingress\"). If absent, the filter will be applied to both flows.",
            "items": {
              "type": "string",
              "enum": [
                "ingress",
                "egress"
              ]
            }
          },
          "messages": {
            "type": "array",
            "description": "List of message type on which the filter will be applied. Must not be empty.",
            "items": {
              "type": "string",
              "enum": [
                "put",
                "delete",
                "query",
                "reply"
              ]
            }
          },
          "key_exprs": {
            "type": "array",
            "description": "List of key_expressions which matching messages will be filtered",
            "items": {
              "type": "string"
            }
          },
          "size_limit": {
            "type": "integer",
            "description": "Inclusive max size of serialized payload + serialized attachment"
          }
        }
      }
    },
    "stats": {
      "type": "object",
      "description": "Enable stats per key expression.",
      "properties": {
        "filters": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "transport": {
      "type": "object",
      "description": "Configure internal transport parameters",
      "properties": {
        "unicast": {
          "type": "object",
          "properties": {
            "open_timeout": {
              "type": "integer",
              "description": "Timeout in milliseconds when opening a link"
            },
            "accept_timeout": {
              "type": "integer",
              "description": "Timeout in milliseconds when accepting a link"
            },
            "accept_pending": {
              "type": "integer",
              "description": "Maximum number of links in pending state while performing the handshake for accepting it"
            },
            "max_sessions": {
              "type": "integer",
              "description": "Maximum number of transports that can be simultaneously alive for a single zenoh sessions"
            },
            "max_links": {
              "type": "integer",
              "description": "Maximum number of incoming links that are admitted per transport"
            },
            "lowlatency": {
              "type": "boolean",
              "description": "Enables the LowLatency transport. This option does not make LowLatency transport mandatory, the actual implementation of transport used will depend on Establish procedure and other party's settings. NOTE: Currently, the LowLatency transport doesn't preserve QoS prioritization. NOTE: Due to the note above, 'lowlatency' is incompatible with 'qos' option, so in order to enable 'lowlatency' you need to explicitly disable 'qos'. NOTE: LowLatency transport does not support the fragmentation, so the message size should be smaller than the tx batch_size."
            },
            "qos": {
              "type": "object",
              "description": "Enables QoS on unicast communications.",
              "properties": {
                "enabled": {
                  "type": "boolean"
                }
              }
            },
            "compression": {
              "type": "object",
              "description": "Enables compression on unicast communications. Compression capabilities are negotiated during session establishment. If both Zenoh nodes support compression, then compression is activated.",
              "properties": {
                "enabled": {
                  "type": "boolean"
                }
              }
            }
          }
        },
        "multicast": {
          "type": "object",
          "description": "WARNING: multicast communication does not perform any negotiation upon group joining. Because of that, it is important that all transport parameters are the same to make sure all your nodes in the system can communicate. One common parameter to configure is \"transport/link/tx/batch_size\" since its default value depends on the actual platform when operating on multicast. E.g., the batch size on Linux and Windows is 65535 bytes, on Mac OS X is 9216, and anything else is 8192.",
          "properties": {
            "join_interval": {
              "type": "integer",
              "description": "JOIN message transmission interval in milliseconds."
            },
            "max_sessions": {
              "type": "integer",
              "description": "Maximum number of multicast sessions."
            },
            "qos": {
              "type": "object",
              "description": "Enables QoS on multicast communication. Default to false for Zenoh-to-Zenoh-Pico out-of-the-box compatibility.",
              "properties": {
                "enabled": {
                  "type": "boolean"
                }
              }
            },
            "compression": {
              "type": "object",
              "description": "Enables compression on multicast communication. Default to false for Zenoh-to-Zenoh-Pico out-of-the-box compatibility.",
              "properties": {
                "enabled": {
                  "type": "boolean"
                }
              }
            }
          }
        },
        "link": {
          "type": "object",
          "description": "An optional whitelist of protocols to be used for accepting and opening sessions. If not configured, all the supported protocols are automatically whitelisted. The supported protocols are: [\"tcp\", \"udp\", \"tls\", \"quic\", \"ws\", \"unixsock-stream\", \"vsock\"]. For example, to only enable \"tls\" and \"quic\": protocols: [\"tls\", \"quic\"]",
          "properties": {
            "protocols": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "tcp",
                  "udp",
                  "tls",
                  "quic",
                  "ws",
                  "unixsock-stream",
                  "vsock"
                ]
              }
            },
            "tx": {
              "type": "object",
              "description": "Configure the zenoh TX parameters of a link",
              "properties": {
                "sequence_number_resolution": {
                  "type": "string",
                  "description": "The resolution in bits to be used for the message sequence numbers. When establishing a session with another Zenoh instance, the lowest value of the two instances will be used. Accepted values: 8bit, 16bit, 32bit, 64bit.",
                  "enum": [
                    "8bit",
                    "16bit",
                    "32bit",
                    "64bit"
                  ]
                },
                "lease": {
                  "type": "integer",
                  "description": "Link lease duration in milliseconds to announce to other zenoh nodes"
                },
                "keep_alive": {
                  "type": "integer",
                  "description": "Number of keep-alive messages in a link lease duration. If no data is sent, keep alive messages will be sent at the configured time interval. NOTE: In order to consider eventual packet loss and transmission latency and jitter, set the actual keep_alive interval to one fourth of the lease time: i.e. send 4 keep_alive messages in a lease period. Changing the lease time will have the keep_alive messages sent more or less often. This is in-line with the ITU-T G.8013/Y.1731 specification on continuous connectivity check which considers a link as failed when no messages are received in 3.5 times the target interval."
                },
                "batch_size": {
                  "type": "integer",
                  "description": "Batch size in bytes is expressed as a 16bit unsigned integer. Therefore, the maximum batch size is 2^16-1 (i.e. 65535). The default batch size value is the maximum batch size: 65535.",
                  "maximum": 65535
                },
                "queue": {
                  "type": "object",
                  "description": "Each zenoh link has a transmission queue that can be configured",
                  "properties": {
                    "size": {
                      "type": "object",
                      "description": "The size of each priority queue indicates the number of batches a given queue can contain. NOTE: the number of batches in each priority must be included between 1 and 16. Different values will result in an error. The amount of memory being allocated for each queue is then SIZE_XXX * BATCH_SIZE. In the case of the transport link MTU being smaller than the ZN_BATCH_SIZE, then amount of memory being allocated for each queue is SIZE_XXX * LINK_MTU. If qos is false, then only the DATA priority will be allocated.",
                      "properties": {
                        "control": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "real_time": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "interactive_high": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "interactive_low": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "data_high": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "data": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "data_low": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        },
                        "background": {
                          "type": "integer",
                          "minimum": 1,
                          "maximum": 16
                        }
                      }
                    },
                    "congestion_control": {
                      "type": "object",
                      "description": "Congestion occurs when the queue is empty (no available batch).",
                      "properties": {
                        "drop": {
                          "type": "object",
                          "description": "Behavior pushing CongestionControl::Drop messages to the queue.",
                          "properties": {
                            "wait_before_drop": {
                              "type": "integer",
                              "description": "The maximum time in microseconds to wait for an available batch before dropping a droppable message if still no batch is available."
                            },
                            "max_wait_before_drop_fragments": {
                              "type": "integer",
                              "description": "The maximum deadline limit for multi-fragment messages."
                            }
                          }
                        },
                        "block": {
                          "type": "object",
                          "description": "Behavior pushing CongestionControl::Block messages to the queue.",
                          "properties": {
                            "wait_before_close": {
                              "type": "integer",
                              "description": "The maximum time in microseconds to wait for an available batch before closing the transport session when sending a blocking message if still no batch is available."
                            }
                          }
                        }
                      }
                    },
                    "batching": {
                      "type": "object",
                      "description": "Perform batching of messages if they are smaller of the batch_size",
                      "properties": {
                        "enabled": {
                          "type": "boolean",
                          "description": "Perform adaptive batching of messages if they are smaller of the batch_size. When the network is detected to not be fast enough to transmit every message individually, many small messages may be batched together and sent all at once on the wire reducing the overall network overhead. This is typically of a high-throughput scenario mainly composed of small messages. In other words, batching is activated by the network back-pressure."
                        },
                        "time_limit": {
                          "type": "integer",
                          "description": "The maximum time limit (in ms) a message should be retained for batching when back-pressure happens."
                        }
                      }
                    },
                    "allocation": {
                      "type": "object",
                      "properties": {
                        "mode": {
                          "type": "string",
                          "description": "Mode for memory allocation of batches in the priority queues. \"init\": batches are allocated at queue initialization time. \"lazy\": batches are allocated when needed up to the maximum number of batches configured in the size configuration parameter.",
                          "enum": [
                            "init",
                            "lazy"
                          ]
                        }
                      }
                    }
                  }
                }
              }
            },
            "rx": {
              "type": "object",
              "description": "Configure the zenoh RX parameters of a link",
              "properties": {
                "buffer_size": {
                  "type": "integer",
                  "description": "Receiving buffer size in bytes for each link. The default the rx_buffer_size value is the same as the default batch size: 65535. For very high throughput scenarios, the rx_buffer_size can be increased to accommodate more in-flight data. This is particularly relevant when dealing with large messages. E.g. for 16MiB rx_buffer_size set the value to: 16777216."
                },
                "max_message_size": {
                  "type": "integer",
                  "description": "Maximum size of the defragmentation buffer at receiver end. Fragmented messages that are larger than the configured size will be dropped. The default value is 1GiB. This would work in most scenarios. NOTE: reduce the value if you are operating on a memory constrained device."
                }
              }
            },
            "tls": {
              "type": "object",
              "description": "Configure TLS specific parameters",
              "properties": {
                "root_ca_certificate": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Path to the certificate of the certificate authority used to validate either the server or the client's keys and certificates, depending on the node's mode. If not specified on router mode then the default WebPKI certificates are used instead."
                },
                "listen_private_key": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Path to the TLS listening side private key"
                },
                "listen_certificate": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Path to the TLS listening side public certificate"
                },
                "enable_mtls": {
                  "type": "boolean",
                  "description": "Enables mTLS (mutual authentication), client authentication"
                },
                "connect_private_key": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Path to the TLS connecting side private key"
                },
                "connect_certificate": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Path to the TLS connecting side certificate"
                },
                "verify_name_on_connect": {
                  "type": "boolean",
                  "description": "Whether or not to verify the matching between hostname/dns and certificate when connecting. If set to false zenoh will disregard the common names of the certificates when verifying servers. This could be dangerous because your CA can have signed a server cert for foo.com, that's later being used to host a server at baz.com. If you want your CA to verify that the server at baz.com is actually baz.com, let this be true (default)."
                },
                "close_link_on_expiration": {
                  "type": "boolean",
                  "description": "Whether or not to close links when remote certificates expires. If set to true, links that require certificates (tls/quic) will automatically disconnect when the time of expiration of the remote certificate chain is reached. Note that mTLS (client authentication) is required for a listener to disconnect a client on expiration."
                },
                "so_rcvbuf": {
                  "type": "integer",
                  "description": "Configure TCP read buffer size (bytes) for TLS links"
                },
                "so_sndbuf": {
                  "type": "integer",
                  "description": "Configure TCP write buffer size (bytes) for TLS links"
                }
              }
            },
            "tcp": {
              "type": "object",
              "description": "Configure optional TCP link specific parameters",
              "properties": {
                "so_rcvbuf": {
                  "type": "integer",
                  "description": "Configure TCP read buffer size (bytes)"
                },
                "so_sndbuf": {
                  "type": "integer",
                  "description": "Configure TCP write buffer size (bytes)"
                }
              }
            }
          }
        },
        "shared_memory": {
          "type": "object",
          "description": "Shared memory configuration. NOTE: shared memory can be used only if zenoh is compiled with \"shared-memory\" feature, otherwise settings in this section have no effect.",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether shared memory is enabled or not. If set to `true`, the SHM buffer optimization support will be announced to other parties. (default `true`). This option doesn't make SHM buffer optimization mandatory, the real support depends on other party setting. A probing procedure for shared memory is performed upon session opening. To enable zenoh to operate over shared memory (and to not fallback on network mode), shared memory needs to be enabled also on the subscriber side. By doing so, the probing procedure will succeed and shared memory will operate as expected."
            },
            "mode": {
              "type": "string",
              "description": "SHM resources initialization mode (default \"lazy\"). \"lazy\": SHM subsystem internals will be initialized lazily upon the first SHM buffer allocation or reception. This setting provides better startup time and optimizes resource usage, but produces extra latency at the first SHM buffer interaction. \"init\": SHM subsystem internals will be initialized upon Session opening. This setting sacrifices startup time, but guarantees no latency impact when first SHM buffer is processed.",
              "enum": [
                "lazy",
                "init"
              ]
            },
            "transport_optimization": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Enables transport optimization for large messages (default `true`). Implicitly puts large messages into shared memory for transports with SHM-compatible connection."
                },
                "pool_size": {
                  "type": "integer",
                  "description": "SHM memory size in bytes used for transport optimization (default `16 * 1024 * 1024`)."
                },
                "message_size_threshold": {
                  "type": "integer",
                  "description": "Allow optimization for messages equal or larger than this threshold in bytes (default `3072`)."
                }
              }
            }
          }
        },
        "auth": {
          "type": "object",
          "description": "The configuration of authentication.",
          "properties": {
            "usrpwd": {
              "type": "object",
              "description": "Username/password authentication. A password implies a username is required.",
              "properties": {
                "user": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "password": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "dictionary_file": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The path to a file containing the user password dictionary"
                }
              }
            },
            "pubkey": {
              "type": "object",
              "description": "Public key authentication.",
              "properties": {
                "public_key_pem": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "private_key_pem": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "public_key_file": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "private_key_file": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "key_size": {
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "known_keys_file": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "adminspace": {
      "type": "object",
      "description": "Configure the Admin Space. Unstable: this configuration part works as advertised, but may change in a future release.",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enables the admin space"
        },
        "permissions": {
          "type": "object",
          "description": "Read and/or write permissions on the admin space",
          "properties": {
            "read": {
              "type": "boolean"
            },
            "write": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "plugins_loading": {
      "type": "object",
      "description": "Plugins loading configuration.",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enable plugins loading."
        },
        "search_dirs": {
          "type": "array",
          "description": "Directories where plugins configured by name should be looked for. Plugins configured by __path__ are not subject to lookup. Directories are specified as object with fields `kind` and `value` is accepted. 1. If `kind` is `current_exe_parent`, then the parent of the current executable's directory is searched and `value` should be `null`. In Bash notation, `{ \"kind\": \"current_exe_parent\" }` equals `$(dirname $(which zenohd))` while \".\" equals `$PWD`. 2. If `kind` is `path`, then `value` is interpreted as a filesystem path. Simply supplying a string instead of a object is equivalent to this. If `enabled: true` and `search_dirs` is not specified then `search_dirs` falls back to the default value.",
          "items": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "object",
                "properties": {
                  "kind": {
                    "type": "string",
                    "enum": [
                      "current_exe_parent",
                      "path"
                    ]
                  },
                  "value": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    },
    "plugins": {
      "type": "object",
      "description": "Plugins configuration. Plugins are only loaded if `plugins_loading: { enabled: true }` and present in the configuration when starting. Once loaded, they may react to changes in the configuration made through the zenoh instance's adminspace. If no `__path__` is given to a plugin, zenohd will automatically search for a shared library matching the plugin's name (e.g., `libzenoh_plugin_rest.so` would be searched for on linux). Plugin settings may contain field `__config__` - If `__config__` is specified, its content is merged into plugin configuration. Properties loaded from `__config__` file overrides existing properties. If json objects in loaded file contains `__config__` properties, they are processed recursively. This is used in the 'storage_manager' which supports subplugins, each with its own config.",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "__required__": {
            "type": "boolean",
            "description": "Setting this option to true allows zenohd to panic should it detect issues with this plugin. Setting it to false politely asks the plugin not to panic. Defaults to false."
          },
          "__config__": {
            "type": "string",
            "description": "Load configuration from the specified file."
          },
          "__path__": {
            "description": "When a path is present, automatic search is disabled, and zenohd will instead select the first path which manages to load.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          }
        },
        "additionalProperties": true
      },
      "properties": {
        "rest": {
          "type": "object",
          "description": "Configure the REST API plugin",
          "properties": {
            "__required__": {
              "type": "boolean"
            },
            "__config__": {
              "type": "string"
            },
            "http_port": {
              "type": "integer",
              "description": "HTTP port to answer to rest requests"
            },
            "work_thread_num": {
              "type": "integer",
              "description": "The number of worker thread in TOKIO runtime (default: 2). The configuration only takes effect if running as a dynamic plugin, which can not reuse the current runtime."
            },
            "max_block_thread_num": {
              "type": "integer",
              "description": "The number of blocking thread in TOKIO runtime (default: 50). The configuration only takes effect if running as a dynamic plugin, which can not reuse the current runtime."
            }
          }
        },
        "storage_manager": {
          "type": "object",
          "description": "Configure the storage manager plugin",
          "properties": {
            "__path__": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "backend_search_dirs": {
              "type": "array",
              "description": "Directories where plugins configured by name should be looked for. Plugins configured by __path__ are not subject to lookup",
              "items": {
                "type": "string"
              }
            },
            "volumes": {
              "type": "object",
              "description": "The \"memory\" volume is always available, but you may create other volumes here, with various backends to support the actual storing.",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "backend": {
                    "type": "string",
                    "description": "A second backend of the same type can be spawned using `backend`, for examples when different DBs are needed."
                  },
                  "url": {
                    "type": "string"
                  },
                  "private": {
                    "type": "object",
                    "description": "Some plugins may need passwords in their configuration. To avoid leaking them through the adminspace, they may be masked behind a privacy barrier. Any value held at the key \"private\" will not be shown in the adminspace.",
                    "properties": {
                      "username": {
                        "type": "string"
                      },
                      "password": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "storages": {
              "type": "object",
              "description": "Configure the storages supported by the volumes",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "key_expr": {
                    "type": "string",
                    "description": "Storages always need to know what set of keys they must work with. These sets are defined by a key expression."
                  },
                  "strip_prefix": {
                    "type": "string",
                    "description": "This prefix will be stripped of the received keys when storing. WARNING: If you replicate this Storage then THIS VALUE SHOULD BE THE SAME FOR ALL THE REPLICAS YOU WANT TO KEEP ALIGNED."
                  },
                  "volume": {
                    "description": "Storages also need to know which volume will be used to actually store their key-value pairs. The \"memory\" volume is always available, and doesn't require any per-storage options, so requesting \"memory\" by string is always sufficient.",
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "string"
                          },
                          "db": {
                            "type": "string"
                          }
                        }
                      }
                    ]
                  },
                  "complete": {
                    "type": "boolean",
                    "description": "A complete storage advertises itself as containing all the known keys matching the configured key expression. If not configured, complete defaults to false."
                  },
                  "garbage_collection": {
                    "type": "object",
                    "description": "Storage manager plugin handles metadata in order to ensure convergence of distributed storages configured in Zenoh. Metadata includes the set of wild card updates and deletions (tombstones). Once the samples are guaranteed to be delivered, the metadata can be garbage collected.",
                    "properties": {
                      "period": {
                        "type": "integer",
                        "description": "The garbage collection event will be periodic with this duration. The duration is specified in seconds."
                      },
                      "lifespan": {
                        "type": "integer",
                        "description": "Metadata older than this parameter will be garbage collected. The duration is specified in seconds."
                      }
                    }
                  },
                  "replication": {
                    "type": "object",
                    "description": "If multiple storages subscribing to the same key_expr should be synchronized, declare them as replicas. In the absence of this configuration, a normal storage is initialized. Note: all the samples to be stored in replicas should be timestamped. WARNING: THESE VALUE SHOULD BE THE SAME FOR ALL THE REPLICAS YOU WANT TO KEEP ALIGNED.",
                    "properties": {
                      "interval": {
                        "type": "number",
                        "description": "Time interval between different synchronization attempts in SECONDS."
                      },
                      "sub_intervals": {
                        "type": "integer",
                        "description": "Number of sub-intervals, of equal duration, within an interval."
                      },
                      "hot": {
                        "type": "integer",
                        "description": "Number of intervals that compose the \"hot\" era."
                      },
                      "warm": {
                        "type": "integer",
                        "description": "Number of intervals that compose the \"warm\" era."
                      },
                      "propagation_delay": {
                        "type": "integer",
                        "description": "The average time, expressed in MILLISECONDS, it takes a publication to reach the Storage."
                      }
                    }
                  }
                },
                "required": [
                  "key_expr",
                  "volume"
                ]
              }
            }
          }
        }
      }
    }
  }
}
